# CURSOR RULES — NOTARIAL AI PROMPT ARCHITECTURE

This project uses a STRICT 4-layer prompt architecture for a notarial AI system.
Your primary responsibility is to PREVENT prompt responsibility leakage and unintended modifications.

====================================================
CRITICAL GOAL
====================================================

When future changes are requested (by a human or by you), you MUST know:
- WHICH prompt is allowed to change
- WHICH prompt is FORBIDDEN to change
- WHEN logic belongs in code instead of prompts

Most past bugs were caused by modifying the WRONG prompt.
This file exists to PREVENT that.

====================================================
PROMPT ARCHITECTURE — SOURCE OF TRUTH
====================================================

There are EXACTLY four prompts. Their responsibilities are NON-OVERLAPPING.

----------------------------------------------------
PROMPT 1 — SYSTEM CORE (Identity & Cognition)
----------------------------------------------------
Location:
- app/api/ai/preaviso-chat/route.ts
- Constant: PROMPT_1_SYSTEM_CORE

Purpose:
- Agent identity
- Cognitive constraints
- Communication style
- Conversation rules
- Order of questioning (high-level, human-facing)

MAY CHANGE IF AND ONLY IF the change is about:
- Tone or language style
- Conversation etiquette
- Question phrasing rules
- Identity constraints (e.g. "you are not a lawyer")
- Human-facing flow order (in natural language terms)

MUST NEVER CHANGE FOR:
- Business rules
- Legal validation
- State machines
- Blocking logic
- JSON schema
- Output formatting
- Domain terminology definitions

----------------------------------------------------
PROMPT 2 — BUSINESS RULES (Domain & Legal Logic)
----------------------------------------------------
Location:
- Database: preaviso_config.prompt

Purpose:
- Legal definitions
- Domain terminology
- State definitions
- Blocking rules
- Persona moral rules
- Registry validation rules
- What is allowed vs forbidden legally

MAY CHANGE IF AND ONLY IF the change is about:
- Legal requirements
- Notarial domain rules
- State definitions or transitions (conceptually)
- Blocking conditions
- Validation logic
- Persona moral constraints
- Registry / folio / hipoteca rules

MUST NEVER CHANGE FOR:
- Conversation tone
- Question phrasing
- Output JSON formatting
- Technical schema constraints
- Runtime session context

HOW TO UPDATE:
- Create a new migration SQL file in supabase/migrations/
- Update preaviso_config.prompt via SQL UPDATE
- NEVER modify PROMPT 2 in code files

----------------------------------------------------
PROMPT 3 — TASK / STATE (Dynamic Runtime Context)
----------------------------------------------------
Location:
- app/api/ai/preaviso-chat/route.ts
- Function: buildSystemPrompts

Purpose:
- Current state snapshot
- Captured data
- Missing data
- Blocking reasons
- Allowed actions THIS TURN

MAY CHANGE IF AND ONLY IF the change is about:
- What runtime context is shown to the model
- State snapshot structure
- Flags like completed / blocked / missing
- Authoritative session data representation

MUST NEVER CHANGE FOR:
- Business rules
- Legal definitions
- Identity or tone
- Output JSON rules
- State transition logic (that belongs in code)

IMPORTANT:
- PROMPT 3 is DESCRIPTIVE, never PRESCRIPTIVE
- It describes reality; it does not decide what happens next
- State determination logic belongs in CODE, not in the prompt text

----------------------------------------------------
PROMPT 4 — TECHNICAL OUTPUT (Output Contract)
----------------------------------------------------
Location:
- app/api/ai/preaviso-chat/route.ts
- Constant: PROMPT_4_TECHNICAL_OUTPUT

Purpose:
- Enforce <DATA_UPDATE> contract
- Control JSON output
- Prevent inference
- Prevent carry-over
- Guarantee schema safety

MAY CHANGE IF AND ONLY IF the change is about:
- JSON schema fields
- Output validation rules
- Emission constraints
- Failure modes
- Output safety

MUST NEVER CHANGE FOR:
- Conversation flow
- Business logic
- Legal rules
- State definitions
- Tone or language

====================================================
ABSOLUTE RULES FOR CURSOR
====================================================

1) NEVER move rules between prompts.
2) NEVER duplicate logic across prompts.
3) NEVER "fix" a bug by editing the wrong prompt.
4) NEVER add state machine logic to PROMPT 1 or PROMPT 3.
5) NEVER add legal rules to PROMPT 4.
6) NEVER add output formatting rules to PROMPT 1 or PROMPT 2.
7) NEVER add conversation rules to PROMPT 2 or PROMPT 4.
8) NEVER add runtime context to PROMPT 1, PROMPT 2, or PROMPT 4.

====================================================
PROMPT AUTHORITY & GOVERNANCE RULES
(STRICT — NON NEGOTIABLE)
====================================================

This project uses a FIXED 4-PROMPT ARCHITECTURE.
Each prompt has EXCLUSIVE RESPONSIBILITY.

Cursor MUST classify every change BEFORE modifying any file.

────────────────────────────────────────
PROMPT RESPONSIBILITY MATRIX
────────────────────────────────────────

PROMPT 1 — SYSTEM CORE (Identity & Cognition)
Allowed changes ONLY IF:
- Change affects tone, communication style, cognition, or non-inference principles
- Change affects how the assistant speaks to users

PROHIBITED:
- Business rules
- State logic
- JSON schema
- Credit logic
- Legal domain constraints

────────────────────────────────────────

PROMPT 2 — BUSINESS RULES (Domain & Legal)
Allowed changes ONLY IF:
- Change affects legal rules
- Change affects blocking conditions
- Change affects credit logic, coacreditados, gravámenes
- Change affects what is legally required or prohibited

PROHIBITED:
- Conversation style
- Output formatting
- JSON structure
- Dynamic state rendering

────────────────────────────────────────

PROMPT 3 — TASK / STATE (Dynamic Context)
Allowed changes ONLY IF:
- Change affects state transitions
- Change affects flow order
- Change affects what question is asked next
- Change affects dynamic completeness checks

PROHIBITED:
- Legal rules
- Domain interpretations
- JSON structure
- Output formatting

────────────────────────────────────────

PROMPT 4 — TECHNICAL OUTPUT (JSON Contract)
Allowed changes ONLY IF:
- Change affects JSON schema
- Change affects output validation
- Change affects <DATA_UPDATE> rules
- Change affects canonical versioning

PROHIBITED:
- Business logic
- State logic
- Conversation flow
- Legal interpretation

────────────────────────────────────────
MANDATORY CHANGE CLASSIFICATION
────────────────────────────────────────

Before implementing ANY change, Cursor MUST answer:

1. What type of change is this?
   - Communication / Cognition
   - Business / Legal
   - Flow / State
   - Output / JSON

2. Which PROMPT owns this responsibility?

3. Which PROMPTS are explicitly FORBIDDEN to modify?

If more than one prompt appears relevant:
→ STOP
→ Ask for clarification
→ Do NOT guess

────────────────────────────────────────
VERSIONING RULES
────────────────────────────────────────

- PROMPT 2 and PROMPT 4 version bumps MUST be explicit (v1.4 → v1.5)
- PROMPT 1 and PROMPT 3 changes MUST NOT alter domain behavior

────────────────────────────────────────
ABSOLUTE RULE
────────────────────────────────────────

Cursor is NOT allowed to:
- Move rules across prompts
- Duplicate logic across prompts
- "Fix" behavior by touching multiple prompts
- Introduce domain assumptions

Violation of this rule is considered a critical regression.

====================================================
WHEN A CHANGE IS REQUESTED
====================================================

Before making ANY change, you MUST:

1) Classify the change into EXACTLY ONE category:
   - Identity / Conversation
   - Legal / Business Rule
   - Runtime State Context
   - Output / Schema / JSON

2) Map the category to the correct prompt:
   - Identity / Conversation → PROMPT 1
   - Legal / Business Rule → PROMPT 2
   - Runtime State Context → PROMPT 3
   - Output / Schema / JSON → PROMPT 4

3) If the change spans more than one category:
   - STOP
   - Ask the human to split the request
   - Explain which parts belong to which prompt

4) Verify the target prompt location:
   - PROMPT 1: app/api/ai/preaviso-chat/route.ts (constant)
   - PROMPT 2: Database (create migration SQL)
   - PROMPT 3: app/api/ai/preaviso-chat/route.ts (function buildSystemPrompts)
   - PROMPT 4: app/api/ai/preaviso-chat/route.ts (constant)

====================================================
CODE VS PROMPT RULE
====================================================

If the change involves:
- State transitions
- Advancing steps
- Determining completeness
- Deciding when to generate output
- Calculating state status
- Determining current_state value

→ This belongs in CODE, NOT in any prompt.

Prompts describe constraints.
Code decides behavior.

PROMPT 3 is generated by CODE and describes the current state.
PROMPT 3 does NOT contain logic to determine the state.

====================================================
COMMON MISTAKES TO AVOID
====================================================

❌ WRONG: Adding blocking rules to PROMPT 1
✅ RIGHT: Blocking rules belong in PROMPT 2

❌ WRONG: Adding JSON schema to PROMPT 2
✅ RIGHT: JSON schema belongs in PROMPT 4

❌ WRONG: Adding conversation rules to PROMPT 2
✅ RIGHT: Conversation rules belong in PROMPT 1

❌ WRONG: Adding state determination logic to PROMPT 3 text
✅ RIGHT: State determination logic belongs in CODE that generates PROMPT 3

❌ WRONG: Modifying PROMPT 2 directly in code
✅ RIGHT: PROMPT 2 must be updated via SQL migration

❌ WRONG: Adding legal definitions to PROMPT 4
✅ RIGHT: Legal definitions belong in PROMPT 2

====================================================
ENFORCEMENT
====================================================

If a future instruction would cause:
- Prompt responsibility leakage
- Mixed concerns
- Silent logic changes
- Duplication across prompts

You MUST refuse and explain:
1) Which prompt is the correct place
2) Why the requested change violates separation
3) How to properly split the change if needed

====================================================
VALIDATION CHECKLIST
====================================================

Before committing ANY prompt change, verify:

[ ] The change affects ONLY one prompt
[ ] The change matches the prompt's responsibility
[ ] No logic was moved between prompts
[ ] No duplication was introduced
[ ] If PROMPT 2: A migration SQL file was created
[ ] If PROMPT 3: Only the generation logic changed, not business rules
[ ] Code logic (state determination) is separate from prompt text

====================================================
FINAL DIRECTIVE
====================================================

Stability is more important than cleverness.
Determinism is more important than convenience.
Do not optimize by collapsing responsibilities.

When in doubt:
- Ask which prompt should change
- Refuse to make ambiguous changes
- Preserve separation of concerns

